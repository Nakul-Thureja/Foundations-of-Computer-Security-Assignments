#FCS Assignment 1, question 1
#Name: Nakul Thureja
#Roll number: 2020528

from urllib.parse import parse_qs
from Crypto.Cipher import Salsa20
import gmpy2
import os
import sys

def alice_generates_symmetric_key():
    '''
    A function that returns a 16 byte string to be used as the key for Salsa20.
    This key should be used to encrypt Bob and Alice's communications.
    But before that, it needs to be sent to Bob.

    Input: NA
    Return: the symmetric key (byte string)
    '''
    return os.urandom(16)


def bob_generates_asymmetric_keys(p ,q):
    '''
    A function that takes in prime numbers p and q and generates
    the public and private keys for Bob as per RSA. Note that you are
    not allowed to use loops to find e or d.

    Input: p, q (upto 1023 digits long)
    Return: Bob's public key and private key ((e,n), (d,n)) as a tuple
    '''
    if p==q:
        print("The prime numbers should be different")
        sys.exit()

    if gmpy2.is_prime(p) and gmpy2.is_prime(q):
        n = p*q 
        phi = (p-1)*(q-1)
        e = gmpy2.next_prime(phi)
        if e > n:
            e = 65537 #5th fermat prime
        d = gmpy2.invert(e, phi)
        return ((e,n), (d,n))

    else:
        print("The numbers are not prime")
        sys.exit()
    

def alice_sends_symmetric_key(k, e, n):
    '''
    A function that Alice uses to encrypt the symmetric key
    using Bob's public key. The ciphertext is sent to Bob.

    Input: the symmetric key k, Bob's public key e, n.
    Return: encrypted ciphertext
    '''
    key = int.from_bytes(k, 'little') #assuming MSB at End
    return gmpy2.powmod(key, e, n)


def bob_decrypts_symmetric_key(c, d, n):
    '''
    A function that Bob uses to decrypt the ciphertext c using his private key.
    The decrypted message would give him the symmetric key.

    Input: the ciphertext c, Bob's private key d, n.
    Return: the symmetric key (byte string)
    '''
    key = gmpy2.powmod(c, d, n)
    return key

def bob_sends_message(m, k):
    '''
    A function that takes a message m, shared key k and uses Salsa20 to encrypt m.

    Input: the message m (a byte string), the shared key k (byte string)
    Return: encrypted ciphertext
    '''
    k = int(k) 
    k = k.to_bytes(16, 'little') #assuming MSB at End
    cipher = Salsa20.new(key=k)
    return cipher.nonce + cipher.encrypt(m)


def alice_decrypts_message(c_, k):
    '''
    A function that takes an encrypted message c_, shared key k and uses Salsa20 to decrypt c_.

    Input: the ciphertext c_, the shared key k (byte string)
    Return: plaintext message
    '''
    cipher = Salsa20.new(key=k, nonce=c_[:8])
    return cipher.decrypt(c_[8:])

if __name__=="__main__":
    # p, q and the message m will be taken as inputs from the user.
    p = int(input("Input a prime number p: "))
    q = int(input("Input a prime number q: "))
    k = alice_generates_symmetric_key()
    print("Symmetric Key Generated by Alice: " + str(k))
    ((e,n),(d,n)) = bob_generates_asymmetric_keys(p, q)
    print("Bob's public key: " + str((e,n)))
    print("Bob's private key: " + str((d,n)))
    c = alice_sends_symmetric_key(k, e, n)
    print("CipherText: " + str(c))
    k_ = bob_decrypts_symmetric_key(c, d, n)
    print("Key Decrypted by Bob: " + str(k_))
    m = input("Input a message m: ").encode()
    c_ = bob_sends_message(m, k_)
    print("Message sent by Bob: " + str(c_))    
    m_ = alice_decrypts_message(c_, k).decode()
    print("Message recieved by Alice: " + str(m_))